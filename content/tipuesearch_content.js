var tipuesearch = {"pages": [{'title': 'About', 'text': '此內容管理系統以\xa0 https://github.com/mdecourse/cmsimde \xa0作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作. \n 利用 cmsimde 建立靜態網誌方法: \n 1. 在 github 建立倉儲, git clone 到近端 \n 2. 參考\xa0 https://github.com/mdecourse/newcms , 加入除了 cmsimde 目錄外的所有內容 \n 以 git submodule add\xa0 https://github.com/mdecourse/cmsimde \xa0cmsimde \n 建立 cmsimde 目錄, 並從 github 取下子模組內容. \n 3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器. \n 動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端. \n 4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行: \n git clone --recurse-submodules  https://github.com/mdecourse/newcms.git \n', 'tags': '', 'url': 'About.html'}, {'title': 'Develop', 'text': 'https://github.com/mdecourse/cmsimde \xa0的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443\xa0就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容. \n cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版. \n init.py 位於\xa0 up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數. \n', 'tags': '', 'url': 'Develop.html'}, {'title': '倉儲與網站', 'text': '\n \n 請重新下載 \xa0 wcmj2020_tool.7z , 檔案大小為 435 MB, 解開壓縮後為 1.8 GB (其中包括 Mypaint, Dia 與 OBS 等). \n \n \n 登入 github.com 建立 Github 倉儲, 直接新增 README.md 檔案. \n \n \n 將所建立的倉儲 git clone 到近端. \n \n \n git submodule add \xa0 https://github.com/mdecourse/cmsimde.git \xa0cmsimde \n \n \n 在近端維護動態網站, 轉為靜態後 git add commit push \n \n \n', 'tags': '', 'url': '倉儲與網站.html'}, {'title': 'Google-Meet', 'text': '是一個可以多人連線通話且分享螢幕的視訊軟體，只要有放到行事曆，並且輸入對方的Gmail帳號就可以連線了，並且可以做線上串流和錄影的功能，且錄完會直接跑到你的遠端上去，真的是很方便呢! \n https://meet.google.com \n', 'tags': '', 'url': 'Google-Meet.html'}, {'title': 'ssh', 'text': '好難 \n', 'tags': '', 'url': 'ssh.html'}, {'title': 'blogger', 'text': '我的blogger :\xa0 https://50833118.blogspot.com/ \n', 'tags': '', 'url': 'blogger.html'}, {'title': '編輯', 'text': '啟用 leo 在leo中開啟 tmp → wcmj2020 → config ，再打開 pelican.leo。 編輯遠端與近端和共用，與倉儲連結。 \n 添加 add_to_blogger \n @language python\n\nfrom markdown import markdown\nfrom oauth2client import client\nfrom googleapiclient import sample_tools\nimport os\n\nos.environ[\'TZ\'] = \'Asia/Taipei\'\nargv = ""\n# 認證並建立服務\n# name of the api is "blogger", version is "v3"\n# description of the api is __doc__\n# file name of the application: location of client_secrets.json\nservice, flags = sample_tools.init(\n  argv, \'blogger\', \'v3\', __doc__, "./../../client_secrets.json",\n  scope=\'https://www.googleapis.com/auth/blogger\')\n\n\ndef get_cat_tag_content(data):\n    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---\n    # 用跳行符號分割\n    data_list = data.split("\\n")\n    #第 2 行為 title\n    title= data_list[1]\n    #第 4 行為 category\n    category = data_list[3]\n    #第 5 行為 tags\n    tags = data_list[4]\n    # 有多項資料的 content 型別為數列\n    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料\n    content = "\\n".join(data_list[8:])\n    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 <!--more-->\n    content = content.replace(\'<!-- PELICAN_END_SUMMARY -->\', \'<!--more-->\')\n    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式\n    #content = content.replace(\'~~~python\', \'[code lang="python"]\')\n    #content = content.replace(\'~~~\', \'[/code]\')\n    return title, category, tags, content\n\n# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容\n# p.h 為 @clean filename.md\n# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案\nmd_filename = p.h.split(" ")[1]\nwith open(md_filename, \'r\', encoding="utf-8") as content_file:\n    md_content = content_file.read()\n# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)\ntitle_str, category_str, tags_str, content = get_cat_tag_content(md_content)\ncategory = category_str.split(":")[1]\ntags = tags_str.split(":")[1].split(",")\ntags.append(category)\n# title 是一個單獨的字串\ntitle = title_str.split(":")[1]\n# 將 markdown 格式 content 轉為 html\ncontent = markdown(content)\n# 以下處理 content 的 <h2> 標題\ncontent = content.replace("<h2>", "<h2><font size=\'4\'>")\ncontent = content.replace("</h2>", "</font></h2>")\n# g.es(content)\n\ntry:\n    \'\'\'\n    users = service.users()\n    # 取得使用者 profile 資料\n    user = users.get(userId=\'self\').execute()\n    print(\'網誌名稱: %s\' % user[\'displayName\'])\n    \'\'\'\n    blogs = service.blogs()\n    # 取得使用者所建立網誌名稱\n    blogs = blogs.listByUser(userId=\'self\').execute()\n    # post_id is now blogs["items"][0]["id"]\n    blog_id = blogs["items"][0]["id"]\n    #for blog in blogs[\'items\']:\n        #print(blog[\'name\'], blog[\'url\'])\n    posts = service.posts()\n    # 新增網誌 post 時, 需要 post_id\n    body = {\n    "kind": "blogger#post",\n    "id": blog_id,\n    "title": title,\n    # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容\n    "content": content,\n    "labels": tags\n    }\n    insert = posts.insert(blogId=blog_id, body=body)\n    posts_doc = insert.execute()\n    post_id = posts_doc["id"]\n    #print(posts_doc)\n    os.remove("blogger.dat")\n    # 利用最後的 child 節點來儲存 post_id\n    to_save_post_id = p.insertAsLastChild()   \n    # 改為內文為空的節點, id 直接標在 head 標題 \n    to_save_post_id.b = ""\n    to_save_post_id.h = post_id\n    # 因為新增節點, commander 必須 redraw\n    c.redraw()\n    g.es("post_id 為", post_id)\n    g.es("已經將資料送往 Blogger!")\nexcept(client.AccessTokenRefreshError):\n    g.es("error") \n edit_to_blogger \n @language python\n\nfrom markdown import markdown\nfrom oauth2client import client\nfrom googleapiclient import sample_tools\nimport os\n\nos.environ[\'TZ\'] = \'Asia/Taipei\'\nargv = ""\n# 認證並建立服務\n# name of the api is "blogger", version is "v3"\n# description of the api is __doc__\n# file name of the application: location of client_secrets.json\nservice, flags = sample_tools.init(\n  argv, \'blogger\', \'v3\', __doc__, "./../../client_secrets.json",\n  scope=\'https://www.googleapis.com/auth/blogger\')\n\n\ndef get_cat_tag_content(data):\n    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---\n    # 用跳行符號分割\n    data_list = data.split("\\n")\n    #第 2 行為 title\n    title= data_list[1]\n    #第 4 行為 category\n    category = data_list[3]\n    #第 5 行為 tags\n    tags = data_list[4]\n    # 有多項資料的 content 型別為數列\n    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料\n    content = "\\n".join(data_list[8:])\n    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 <!--more-->\n    content = content.replace(\'<!-- PELICAN_END_SUMMARY -->\', \'<!--more-->\')\n    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式\n    #content = content.replace(\'~~~python\', \'[code lang="python"]\')\n    #content = content.replace(\'~~~\', \'[/code]\')\n    return title, category, tags, content\n\n# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容\n# p.h 為 @clean filename.md\n# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案\nmd_filename = p.h.split(" ")[1]\nwith open(md_filename, \'r\', encoding="utf-8") as content_file:\n    md_content = content_file.read()\n# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)\ntitle_str, category_str, tags_str, content = get_cat_tag_content(md_content)\ncategory = category_str.split(":")[1]\ntags = tags_str.split(":")[1].split(",")\ntags.append(category)\n# title 是一個單獨的字串\ntitle = title_str.split(":")[1]\n# 將 markdown 格式 content 轉為 html\ncontent = markdown(content)\n# 以下處理 content 的 <h2> 標題\ncontent = content.replace("<h2>", "<h2><font size=\'4\'>")\ncontent = content.replace("</h2>", "</font></h2>")\n# g.es(content)\n\ntry:\n    blogs = service.blogs()\n    # 取得使用者所建立網誌名稱\n    blogs = blogs.listByUser(userId=\'self\').execute()\n    blog_id = blogs["items"][0]["id"]\n    # 設法取得原 post 的 id\n    postid_outline = p.getLastChild()\n    # 直接從標題取得 post 的 id 號碼\n    post_id = postid_outline.h\n    posts = service.posts()\n    # 更新網誌文章時的 body\n    body = {\n    "kind": "blogger#post",\n    "title": title,\n    "content": content\n    }\n    # need to save postId to outline head\n    update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True)\n    update_doc = update.execute()\n    os.remove("blogger.dat")\n    g.es("post_id 為", post_id)\n    g.es("已經將更新資料送往 Blogger!")\nexcept(client.AccessTokenRefreshError):\n    g.es("error") \n 在markdown下新增文章 \n \n \n 選擇主檔案，按add_to_blogger，文章就會推到blogger上；如要編輯在leo裡編輯， 選擇主檔案，按edit_to_blogger ， 文章就會更新到blogger上。', 'tags': '', 'url': '編輯.html'}]};